{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.trim = trim;\nexports.appendError = appendError;\nexports.extractPath = extractPath;\nexports.getDirectoryByPath = getDirectoryByPath;\nexports.getEnvVariables = getEnvVariables;\nexports.isFile = isFile;\n\nvar _const = require('./const');\n/*\n * This is a utility method for trimming the beginning\n * and ending of a string of any given char.\n *\n * @param {string} str - the string the trim\n * @param {string} char - the char to remove\n * @returns {string} the trimmed string\n */\n\n\nfunction trim(str, char) {\n  if (str[0] === char) {\n    str = str.substr(1);\n  }\n\n  if (str[str.length - 1] === char) {\n    str = str.substr(0, str.length - 1);\n  }\n\n  return str;\n}\n/*\n * This is a utility method for appending an error\n * message to the current state.\n *\n * @param {Object} state - the terminal state\n * @param {string} error - the error to interpolate\n * @param {string} command - the string to insert\n * @returns {Object} the new terminal state\n */\n\n\nfunction appendError(state, error, command) {\n  return Object.assign({}, state, {\n    error: true,\n    history: state.history.concat({\n      value: error.replace('$1', command)\n    })\n  });\n}\n/*\n * This is a utility method for appending a relative path\n * to a root path. Handles trimming and backtracking.\n *\n * @param {string} relativePath\n * @param {string} rootPath\n * @returns {string} the combined path\n */\n\n\nfunction extractPath(relativePath, rootPath) {\n  // Short circuit for relative path\n  if (relativePath === '') return rootPath; // Strip trailing slash\n\n  relativePath = trim(relativePath, '/'); // Create raw path\n\n  var path = '' + (rootPath ? rootPath + '/' : '') + relativePath; // Strip ../ references\n\n  while (path.match(_const.BACK_REGEX)) {\n    path = path.replace(_const.BACK_REGEX, '');\n  }\n\n  return trim(path, '/');\n}\n/*\n * This is a utility method for traversing the structure\n * down the relative path.\n *\n * @param {Object} structure - the terminal file structure\n * @param {string} relativePath - the path of the directory\n * @returns {Object} the directory or error\n */\n\n\nfunction getDirectoryByPath(structure, relativePath) {\n  var path = relativePath.split('/'); // Short circuit for empty root path\n\n  if (!path[0]) return {\n    dir: structure\n  };\n  var dir = structure;\n  var i = 0;\n\n  while (i < path.length) {\n    var key = path[i];\n    var child = dir[key];\n\n    if (child && (typeof child === 'undefined' ? 'undefined' : _typeof(child)) === 'object') {\n      if (child.hasOwnProperty('content')) {\n        return {\n          err: _const.Errors.NOT_A_DIRECTORY.replace('$1', relativePath)\n        };\n      } else {\n        dir = child;\n      }\n    } else {\n      return {\n        err: _const.Errors.NO_SUCH_FILE.replace('$1', relativePath)\n      };\n    }\n\n    i++;\n  }\n\n  return {\n    dir: dir\n  };\n}\n/*\n * This is a utility method for getting the environment\n * variables with the dynamic values updated with state.\n *\n * @param {Object} state - the terminal state\n * @returns {Object} the updated env variables\n */\n\n\nfunction getEnvVariables(state) {\n  return Object.keys(_const.EnvVariables).reduce(function (envVars, key) {\n    var value = _const.EnvVariables[key];\n    envVars[key] = typeof value === 'function' ? value(state) : value;\n    return envVars;\n  }, {});\n}\n/*\n * This is a utility method for determining if a given filesystem entry is a\n * file or directoy.\n *\n * @param {Object} entry - the filesystem entry\n * @returns {Boolean} whether the entry is a file\n */\n\n\nfunction isFile(entry) {\n  return entry.content !== undefined;\n}","map":null,"metadata":{},"sourceType":"script"}