{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseInput = parseInput;\nexports.parse = parse;\n/*\n * This method parses a single command + args. It handles\n * the tokenization and processing of flags, anonymous args,\n * and named args.\n *\n * @param {string} input - the user input to parse\n * @returns {Object} the parsed command/arg dataf84t56y78ju7y6f\n */\n\nfunction parseInput(input) {\n  var tokens = input.split(/ +/);\n  var name = tokens.shift();\n  var flags = {};\n  var args = {};\n  var anonArgPos = 0;\n\n  while (tokens.length > 0) {\n    var token = tokens.shift();\n\n    if (token[0] === '-') {\n      if (token[1] === '-') {\n        var next = tokens.shift();\n        args[token.slice(2)] = next;\n      } else {\n        token.slice(1).split('').forEach(function (flag) {\n          flags[flag] = true;\n        });\n      }\n    } else {\n      args[anonArgPos++] = token;\n    }\n  }\n\n  return {\n    name: name,\n    flags: flags,\n    input: input,\n    args: args\n  };\n}\n/*\n * This function splits the input by `&&`` creating a\n * dependency chain. The chain consists of a list of\n * other commands to be run.\n *\n * @param {string} input - the user input\n * @returns {Array} a list of lists of command/arg pairs\n *\n * Example: `cd dir1; cat file.txt && pwd`\n * In this example `pwd` should only be run if dir/file.txt\n * is a readable file. The corresponding response would look\n * like this, where the outer list is the dependent lists..\n *\n * [\n *   [\n *     { command: 'cd', args: { 0: 'dir1'} },\n *     { command: 'cat', args: { 0: 'file.txt'} }\n *   ],\n *   [\n *     { command: 'pwd' }\n *   ]\n * ]\n */\n\n\nfunction parse(inputs) {\n  return inputs.trim().split(/ *&& */).map(function (deps) {\n    return deps.split(/ *; */).map(parseInput);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}