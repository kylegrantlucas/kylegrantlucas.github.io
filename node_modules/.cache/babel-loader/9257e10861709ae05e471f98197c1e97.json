{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _util = require('./util');\n\nvar Util = _interopRequireWildcard(_util);\n\nvar _const = require('./const');\n\nvar _commands = require('./commands');\n\nvar BaseCommands = _interopRequireWildcard(_commands);\n\nvar _parser = require('./parser');\n\nvar BashParser = _interopRequireWildcard(_parser);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Bash = function () {\n  function Bash() {\n    var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Bash);\n\n    this.commands = Object.assign({}, BaseCommands, extensions);\n    this.prevCommands = [];\n    this.prevCommandsIndex = 0;\n  }\n  /*\n   * This parses and executes the given <input> and returns an updated\n   * state object.\n   *\n   * @param {string} input - the user input\n   * @param {Object} state - the current terminal state\n   * @returns {Object} the new terminal state\n   */\n\n\n  _createClass(Bash, [{\n    key: 'execute',\n    value: function execute(input, currentState) {\n      this.prevCommands.push(input);\n      this.prevCommandsIndex = this.prevCommands.length; // Append input to history\n\n      var newState = Object.assign({}, currentState, {\n        history: currentState.history.concat({\n          cwd: currentState.cwd,\n          value: input\n        })\n      });\n      var commandList = BashParser.parse(input);\n      return this.runCommands(commandList, newState);\n    }\n    /*\n     * This function executes a list of command lists. The outer list\n     * is a dependency list parsed from the `&&` operator. The inner lists\n     * are groups of commands parsed from the `;` operator. If any given\n     * command fails, the outer list will stop executing.\n     *\n     * @param {Array} commands - the commands to run\n     * @param {Object} state - the terminal state\n     * @returns {Object} the new terminal state\n     */\n\n  }, {\n    key: 'runCommands',\n    value: function runCommands(commands, state) {\n      var _this = this;\n\n      var errorOccurred = false;\n      /*\n       * This function executes a single command and marks whether an error\n       * occurred. If an error occurs, the following dependent commands should\n       * not be run.\n       */\n\n      var reducer = function reducer(newState, command) {\n        if (command.name === '') {\n          return newState;\n        } else if (_this.commands[command.name]) {\n          var nextState = _this.commands[command.name].exec(newState, command);\n\n          errorOccurred = errorOccurred || nextState && nextState.error;\n          return nextState;\n        } else {\n          errorOccurred = true;\n          return Util.appendError(newState, _const.Errors.COMMAND_NOT_FOUND, command.name);\n        }\n      };\n\n      while (!errorOccurred && commands.length) {\n        var dependentCommands = commands.shift();\n        state = dependentCommands.reduce(reducer, state);\n      }\n\n      return state;\n    }\n    /*\n     * This is a very naive autocomplete method that works for both\n     * commands and directories. If the input contains only one token it\n     * should only suggest commands.\n     *\n     * @param {string} input - the user input\n     * @param {Object} state - the terminal state\n     * @param {Object} state.structure - the file structure\n     * @param {string} state.cwd - the current working directory\n     * @returns {?string} a suggested autocomplete for the <input>\n     */\n\n  }, {\n    key: 'autocomplete',\n    value: function autocomplete(input, _ref) {\n      var structure = _ref.structure,\n          cwd = _ref.cwd;\n      var tokens = input.split(/ +/);\n      var token = tokens.pop();\n\n      var filter = function filter(item) {\n        return item.indexOf(token) === 0;\n      };\n\n      var result = function result(str) {\n        return tokens.concat(str).join(' ');\n      };\n\n      if (tokens.length === 0) {\n        var suggestions = Object.keys(this.commands).filter(filter);\n        return suggestions.length === 1 ? result(suggestions[0]) : null;\n      } else {\n        var pathList = token.split('/');\n        token = pathList.pop();\n        var partialPath = pathList.join('/');\n        var path = Util.extractPath(partialPath, cwd);\n\n        var _Util$getDirectoryByP = Util.getDirectoryByPath(structure, path),\n            err = _Util$getDirectoryByP.err,\n            dir = _Util$getDirectoryByP.dir;\n\n        if (err) return null;\n\n        var _suggestions = Object.keys(dir).filter(filter);\n\n        var prefix = partialPath ? partialPath + '/' : '';\n        return _suggestions.length === 1 ? result('' + prefix + _suggestions[0]) : null;\n      }\n    }\n  }, {\n    key: 'getPrevCommand',\n    value: function getPrevCommand() {\n      return this.prevCommands[--this.prevCommandsIndex];\n    }\n  }, {\n    key: 'getNextCommand',\n    value: function getNextCommand() {\n      return this.prevCommands[++this.prevCommandsIndex];\n    }\n  }, {\n    key: 'hasPrevCommand',\n    value: function hasPrevCommand() {\n      return this.prevCommandsIndex !== 0;\n    }\n  }, {\n    key: 'hasNextCommand',\n    value: function hasNextCommand() {\n      return this.prevCommandsIndex !== this.prevCommands.length - 1;\n    }\n  }]);\n\n  return Bash;\n}();\n\nexports.default = Bash;","map":null,"metadata":{},"sourceType":"script"}