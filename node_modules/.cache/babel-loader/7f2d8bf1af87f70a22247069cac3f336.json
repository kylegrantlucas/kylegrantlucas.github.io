{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rm = exports.whoami = exports.printenv = exports.echo = exports.pwd = exports.cd = exports.mkdir = exports.cat = exports.ls = exports.help = undefined;\n\nvar _util = require('./util');\n\nvar Util = _interopRequireWildcard(_util);\n\nvar _const = require('./const');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar helpCommands = ['ls', 'cat', 'mkdir', 'cd', 'pwd', 'echo', 'printenv', 'whoami', 'rm'];\nvar help = exports.help = {\n  exec: function exec(state) {\n    var _state$history;\n\n    return Object.assign({}, state, {\n      history: (_state$history = state.history).concat.apply(_state$history, [{\n        value: 'React-bash:'\n      }, {\n        value: 'These shell commands are defined internally.  Type \\'help\\' to see this list.'\n      }].concat(_toConsumableArray(helpCommands.map(function (value) {\n        return {\n          value: value\n        };\n      }))))\n    });\n  }\n};\nvar ls = exports.ls = {\n  exec: function exec(state, _ref) {\n    var flags = _ref.flags,\n        args = _ref.args;\n    var path = args[0] || '';\n    var fullPath = Util.extractPath(path, state.cwd);\n\n    var _Util$getDirectoryByP = Util.getDirectoryByPath(state.structure, fullPath),\n        err = _Util$getDirectoryByP.err,\n        dir = _Util$getDirectoryByP.dir;\n\n    if (err) {\n      return Util.appendError(state, err, path);\n    } else {\n      var content = Object.keys(dir);\n\n      if (!flags.a) {\n        content = content.filter(function (name) {\n          return name[0] !== '.';\n        });\n      }\n\n      if (flags.l) {\n        return Object.assign({}, state, {\n          history: state.history.concat(content.map(function (value) {\n            return {\n              value: value\n            };\n          }))\n        });\n      } else {\n        return Object.assign({}, state, {\n          history: state.history.concat({\n            value: content.join(' ')\n          })\n        });\n      }\n    }\n  }\n};\nvar cat = exports.cat = {\n  exec: function exec(state, _ref2) {\n    var args = _ref2.args;\n    var path = args[0];\n    var relativePath = path.split('/');\n    var fileName = relativePath.pop();\n    var fullPath = Util.extractPath(relativePath.join('/'), state.cwd);\n\n    var _Util$getDirectoryByP2 = Util.getDirectoryByPath(state.structure, fullPath),\n        err = _Util$getDirectoryByP2.err,\n        dir = _Util$getDirectoryByP2.dir;\n\n    if (err) {\n      return Util.appendError(state, err, path);\n    } else if (!dir[fileName]) {\n      return Util.appendError(state, _const.Errors.NO_SUCH_FILE, path);\n    } else if (!dir[fileName].hasOwnProperty('content')) {\n      return Util.appendError(state, _const.Errors.IS_A_DIRECTORY, path);\n    } else {\n      return Object.assign({}, state, {\n        history: state.history.concat({\n          value: dir[fileName].content\n        })\n      });\n    }\n  }\n};\nvar mkdir = exports.mkdir = {\n  exec: function exec(state, _ref3) {\n    var args = _ref3.args;\n    var path = args[0];\n    var relativePath = path.split('/');\n    var newDirectory = relativePath.pop();\n    var fullPath = Util.extractPath(relativePath.join('/'), state.cwd);\n    var deepCopy = JSON.parse(JSON.stringify(state.structure));\n\n    var _Util$getDirectoryByP3 = Util.getDirectoryByPath(deepCopy, fullPath),\n        dir = _Util$getDirectoryByP3.dir;\n\n    if (dir[newDirectory]) {\n      return Util.appendError(state, _const.Errors.FILE_EXISTS, path);\n    } else {\n      dir[newDirectory] = {};\n      return Object.assign({}, state, {\n        structure: deepCopy\n      });\n    }\n  }\n};\nvar cd = exports.cd = {\n  exec: function exec(state, _ref4) {\n    var args = _ref4.args;\n    var path = args[0];\n\n    if (!path || path === '/') {\n      return Object.assign({}, state, {\n        cwd: ''\n      });\n    }\n\n    var fullPath = Util.extractPath(path, state.cwd);\n\n    var _Util$getDirectoryByP4 = Util.getDirectoryByPath(state.structure, fullPath),\n        err = _Util$getDirectoryByP4.err;\n\n    if (err) {\n      return Util.appendError(state, err, path);\n    } else {\n      return Object.assign({}, state, {\n        cwd: fullPath\n      });\n    }\n  }\n};\nvar pwd = exports.pwd = {\n  exec: function exec(state) {\n    var directory = '/' + state.cwd;\n    return Object.assign({}, state, {\n      history: state.history.concat({\n        value: directory\n      })\n    });\n  }\n};\nvar echo = exports.echo = {\n  exec: function exec(state, _ref5) {\n    var input = _ref5.input;\n    var ECHO_LENGTH = 'echo '.length;\n    var envVariables = Util.getEnvVariables(state);\n    var value = input.slice(ECHO_LENGTH).replace(/(\\$\\w+)/g, function (key) {\n      return envVariables[key.slice(1)] || '';\n    });\n    return Object.assign({}, state, {\n      history: state.history.concat({\n        value: value\n      })\n    });\n  }\n};\nvar printenv = exports.printenv = {\n  exec: function exec(state) {\n    var envVariables = Util.getEnvVariables(state);\n    var values = Object.keys(envVariables).map(function (key) {\n      return {\n        value: key + '=' + envVariables[key]\n      };\n    });\n    return Object.assign({}, state, {\n      history: state.history.concat(values)\n    });\n  }\n};\nvar whoami = exports.whoami = {\n  exec: function exec(state) {\n    var value = state.settings.user.username;\n    return Object.assign({}, state, {\n      history: state.history.concat({\n        value: value\n      })\n    });\n  }\n};\nvar rm = exports.rm = {\n  exec: function exec(state, _ref6) {\n    var flags = _ref6.flags,\n        args = _ref6.args;\n    var path = args[0];\n    var relativePath = path.split('/');\n    var file = relativePath.pop();\n    var fullPath = Util.extractPath(relativePath.join('/'), state.cwd);\n    var deepCopy = JSON.parse(JSON.stringify(state.structure));\n\n    var _Util$getDirectoryByP5 = Util.getDirectoryByPath(deepCopy, fullPath),\n        dir = _Util$getDirectoryByP5.dir;\n\n    if (dir[file]) {\n      // folder deletion requires the recursive flags `-r` or `-R`\n      if (!Util.isFile(dir[file]) && !(flags.r || flags.R)) {\n        return Util.appendError(state, _const.Errors.IS_A_DIRECTORY, path);\n      }\n\n      delete dir[file];\n      return Object.assign({}, state, {\n        structure: deepCopy\n      });\n    } else {\n      return Util.appendError(state, _const.Errors.NO_SUCH_FILE, path);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}